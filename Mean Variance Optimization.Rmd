---
title: "CAPM model"
output: html_document
date: "2025-10-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  fig.width=10, fig.height=5
)
```

# Pakker
```{r}
library(tidyverse)
library(frenchdata)
library(ggplot2)
library(quadprog)
library(lubridate)
library(lpSolve)
```

# Loading data
```{r}
data_sets = get_french_data_list() # All the datasets in the package


# US stocks
# Nr 1 er månedlige returns
# Nr 2 er årlige returns
ff_3_factors <- download_french_data("Fama/French 3 Factors") # Download of data
# f_3_factors$subsets$data[[2]] # How to extract dataset
# browse_details_page(ff_3_factors) # Details of the dataset


size_mom_6 <- download_french_data("6 Portfolios Formed on Size and Momentum (2 x 3)")
size_mom_25 <- download_french_data("25 Portfolios Formed on Size and Momentum (5 x 5)")

# EU stocks in US dollars
size_mom_6_euro <- download_french_data("6 European Portfolios Formed on Size and Momentum (2 x 3)")
size_mom_25_euro <- download_french_data("25 European Portfolios Formed on Size and Momentum (5 x 5)")

# Other
exchange_rate <- read_csv("Data AA/eurofxref-hist.csv")

Exchange_rate_US <- exchange_rate %>% 
  filter(Date >= "2004-09-01", Date <= "2025-08-31") %>% 
  select(c("Date", "USD"))
Exchange_rate_US <- Exchange_rate_US[nrow(Exchange_rate_US):1,]

Exchange_rate_US <- Exchange_rate_US %>% 
  mutate(Date = floor_date(Date, " month")) %>% 
  group_by(Date) %>% 
  summarise(USD = mean(USD))

RF.EU <- read_rds("All_years_ready.rds")
RF.EU <- select(RF.EU, c("TIME_PERIOD", "return"))

factors <- read_rds("new_factors_all.rds")
```


# Mean variance
## Function to do the optimization
```{r}
optimize_portfolio <- function(excess_returns, cov_period){
  n_assets <- length(excess_returns)
  
  Dmat <- cov_period
  dvec <- rep(0, n_assets)
  Amat <- cbind(rep(1, n_assets), diag(n_assets))
  bvec <- c(
    1,                   # The value for the first constraint (sum(...) = 1)
    rep(0, n_assets)     # The values for the w_i >= 0 constraints
  )
  meq <- 1
  
  sol<- solve.QP(Dmat = Dmat,
                              dvec = dvec,
                              Amat = Amat,
                              bvec = bvec,
                              meq = meq)
  w <- sol$solution/sum(sol$solution)
  return(w)
}

optimize_internal <- function(excess_returns, cov_period, target_return){
  n_assets <- length(excess_returns)
  
  Dmat <- cov_period
  dvec <- rep(0, n_assets)
  Amat <- cbind(rep(1, n_assets), excess_returns, diag(n_assets))
  bvec <- c(
    1,                   # The value for the first constraint (sum(...) = 1)
    target_return,
    rep(0, n_assets)     # The values for the w_i >= 0 constraints
  )
  meq <- 2
  
  sol<- solve.QP(Dmat = Dmat,
                              dvec = dvec,
                              Amat = Amat,
                              bvec = bvec,
                              meq = meq)
  w <- sol$solution/sum(sol$solution)
  return(w)
}


optimize_return <- function(excess_returns){
  n_assets <- length(excess_returns)
  objective.in <- excess_returns
  const.mat <- matrix(rep(1, n_assets), nrow = 1)
  const.dir <- "=="
  const.rhs <- 1
  
  solution <- lp(
    direction = "max",
    objective.in = objective.in,
    const.mat = const.mat,
    const.dir = const.dir,
    const.rhs = const.rhs
  )
  return(solution$solution)
}



```

## Min variance
```{r}
size_mom_6_EU <- size_mom_6_euro$subsets$data[[1]] %>% filter(date >= 200409 & date <= 202412)

excess_returns_EU <- sweep(size_mom_6_EU[,-1], 1, RF.EU$return, "-") %>% 
  mutate(.before = 1, date = size_mom_6_EU$date)


RF.US <- ff_3_factors$subsets$data[[1]] %>% filter(date >= 200409 & date <= 202412) %>% 
  select(c("date", "RF"))

exchange_rate_US <- select(exchange_rate, c("Date", "USD")) %>% 
  filter(Date >= "2004-09-01" & Date <= "2024-12-31") %>% 
  mutate(Date = floor_date(Date, "month")) %>% 
  group_by(Date) %>% 
  summarise(USD = mean(USD))


size_mom_6_US <- size_mom_6$subsets$data[[1]] %>% filter(date >= 200409 & date <= 202412)
size_mom_6_US[,-1] <- sweep(size_mom_6_EU[,-1], 1, exchange_rate_US$USD, "/")

excess_returns_US <- sweep(size_mom_6_US[,-1], 1, RF.EU$return, "-") %>% 
  mutate(.before = 1, date = size_mom_6_US$date)

excess_returns <- left_join(excess_returns_EU, excess_returns_US, by = "date", suffix = c(".EU", ".US"))


n <- nrow(excess_returns)-35-1
w_matrix3 <- matrix(NA, nrow = n, ncol = 12)

for(i in 1:n){
  returns_period <- excess_returns[i:(i+35),-1]
  mu <- colMeans(returns_period)
  cov_period <- cov(returns_period)
  
  if(all(mu <= 0)){
    w_matrix3[i,] <- 0
  } else{
    w_matrix3[i,] <- optimize_portfolio(mu, cov_period)
  }
}
w_df3 <- as_tibble(w_matrix3)
names(w_df3) <- names(excess_returns[, -1])
w_df3 <- w_df3 %>% 
  mutate(.before = 1, date = size_mom_6_EU$date[36:(nrow(size_mom_6_EU)-1)])
w_df3 <- mutate(w_df3, RF = 1-rowSums(w_df3[,-1]))
round(w_df3, 3)

rowSums(w_df3[,-1])

returns <- left_join(size_mom_6_EU, size_mom_6_US, by = "date", suffix = c(".EU", ".US"))
returns$RF <- RF.EU$return
returns <- returns %>% filter(date >= "200709" & date <= "202412")

return_strat <- round(returns[,-1] * w_df3[,-1], 3)

ggplot(mapping = aes(x = rowSums(return_strat))) + 
  geom_histogram(color = "white") +
  geom_vline(xintercept = quantile(rowSums(return_strat), p = c(0.025, 0.975)))

# mean(rowSums(return_strat))
```

## Max return
```{r}
n <- nrow(excess_returns)-35-1
w_matrix_max_return <- matrix(NA, nrow = n, ncol = 12)

for(i in 1:n){
  returns_period <- excess_returns[i:(i+35),-1]
  mu <- colMeans(returns_period)
  
  
  if(all(mu <= 0)){
    w_matrix_max_return[i,] <- 0
  } else{
    w_matrix_max_return[i,] <- optimize_return(mu)
  }
}

w_max_return <- as_tibble(w_matrix_max_return)
names(w_max_return) <- names(excess_returns[, -1])
w_max_return <- w_max_return %>% 
  mutate(.before = 1, date = size_mom_6_EU$date[36:(nrow(size_mom_6_EU)-1)])
w_max_return <- mutate(w_max_return, RF = 1-rowSums(w_max_return[,-1]))
round(w_max_return, 3)

max_return_strat <- round(returns[,-1] * w_max_return[,-1], 3)
mean(rowSums(max_return_strat[,-1]))

```

## Efficient frontier
```{r}
factors_excess_return <- sweep(factors[,-1], 1, RF.EU$return, "-")
factors_excess_return <- cbind(factors$date, factors_excess_return)



n_assets <- ncol(factors_excess_return[,-1])
n <- nrow(factors_excess_return) - 35 - 1
w_min_var <- matrix(NA, nrow = n, ncol = n_assets)
w_max_return <- matrix(NA, nrow = n, ncol = n_assets)

n_internal <- 5
w_internal <- array(NA, dim = c(n_internal, n, n_assets))
target_returns <- array(NA, c(n, n_internal))
Sigma <- array(NA, c(n, n_assets, n_assets))
mu <- array(NA, c(n, n_assets))

for(i in 1:n){
  excess_returns_period <- factors_excess_return[i:(i+35),-1]
  mu[i,] <- colMeans(excess_returns_period)
  Sigma[i,,] <- cov(excess_returns_period)
  if(all(mu <= 0)){
    w_min_var[i,] <- 0
    w_max_return[i,] <- 0
    w_internal[,i , ] <- 0
    target_returns[i,] <- 0
  } else{
    w_min_var[i,] <- optimize_portfolio(mu[i,], Sigma[i,,])
    w_max_return[i,] <- optimize_return(mu[i,])
    
    return_min_var <- sum(mu[i,]*w_min_var[i,])
    return_max_return <- sum(mu[i,]*w_max_return[i,])
    
    target_returns_tmp <- seq(return_min_var, return_max_return, (return_max_return - return_min_var)/(n_internal+1))
    target_returns[i,] <- target_returns_tmp[-c(1, length(target_returns_tmp))]
    for(j in 1:length(target_returns[i,])){
      w_internal[j,i,] <- optimize_internal(mu[i,], Sigma[i,,], target_returns[i,j])
    }
  }
}

colnames(w_min_var) <- colnames(factors[,-1])
current_dimnames <- dimnames(w_internal)
current_dimnames[[3]] <- colnames(factors[,-1])
dimnames(w_internal) <- current_dimnames
colnames(w_max_return) <- colnames(factors[,-1])

factors_period <- factors[37:nrow(factors),]

return_min_var <- rowSums(w_min_var*factors_period[,-1])
return_max_return <- rowSums(w_max_return*factors_period[,-1])
return_internal <- array(NA, c(n, n_internal))
for(i in 1:n_internal){
  return_internal[,i] <- rowSums(w_internal[i,,]*factors_period[,-1])
}
```

```{r Uden ad hoc}
factors_excess_return <- sweep(factors[,-1], 1, RF.EU$return, "-")
factors_excess_return <- cbind(factors$date, factors_excess_return)



n_assets <- ncol(factors_excess_return[,-1])
n <- nrow(factors_excess_return) - 35 - 1
w_min_var <- matrix(NA, nrow = n, ncol = n_assets)
w_max_return <- matrix(NA, nrow = n, ncol = n_assets)

n_internal <- 5
w_internal <- array(NA, dim = c(n_internal, n, n_assets))
target_returns <- array(NA, c(n, n_internal))
Sigma <- array(NA, c(n, n_assets, n_assets))
mu <- array(NA, c(n, n_assets))

for(i in 1:n){
  excess_returns_period <- factors_excess_return[i:(i+35),-1]
  mu[i,] <- colMeans(excess_returns_period)
  Sigma[i,,] <- cov(excess_returns_period)
    w_min_var[i,] <- optimize_portfolio(mu[i,], Sigma[i,,])
    w_max_return[i,] <- optimize_return(mu[i,])
    
    return_min_var <- sum(mu[i,]*w_min_var[i,])
    return_max_return <- sum(mu[i,]*w_max_return[i,])
    
    target_returns_tmp <- seq(return_min_var, return_max_return, (return_max_return - return_min_var)/(n_internal+1))
    target_returns[i,] <- target_returns_tmp[-c(1, length(target_returns_tmp))]
    for(j in 1:length(target_returns[i,])){
      w_internal[j,i,] <- optimize_internal(mu[i,], Sigma[i,,], target_returns[i,j])
    }
}

colnames(w_min_var) <- colnames(factors[,-1])
current_dimnames <- dimnames(w_internal)
current_dimnames[[3]] <- colnames(factors[,-1])
dimnames(w_internal) <- current_dimnames
colnames(w_max_return) <- colnames(factors[,-1])

factors_period <- factors[37:nrow(factors),]

return_min_var <- rowSums(w_min_var*factors_period[,-1])
return_max_return <- rowSums(w_max_return*factors_period[,-1])
return_internal <- array(NA, c(n, n_internal))
for(i in 1:n_internal){
  return_internal[,i] <- rowSums(w_internal[i,,]*factors_period[,-1])
}
```

### Plot af efficient frontier
```{r}
var_func <- function(w, Sigma, k){
  return(
    t(w[k,])%*%Sigma[k,,]%*%w[k,]
  )
}

k <- 208

variance_k <- c(var_func(w_min_var, Sigma, k))
for(i in 1:n_internal){
  variance_k <- c(variance_k, var_func(w_internal[i,,], Sigma, k))
}
variance_k <- c(variance_k, var_func(w_max_return, Sigma, k))

# returns 
return_min_var_k <- sum(w_min_var[k,]*mu[k,])
return_max_return_k <- sum(w_max_return[k,]*mu[k,])
return_internal_k <- rep(NA, n_internal)
for(i in 1:n_internal){
  return_internal_k[i] <- sum(w_internal[i,k,]*mu[k,])
}
return_k <- c(return_min_var_k, return_internal_k, return_max_return_k)
return_k

df_frontier <- tibble(
  "variance" = variance_k,
  "Return" = return_k
)

factors[k:(nrow(factors)-1),]

ggplot(df_frontier, aes(variance, Return)) +
  geom_point() +
  ggtitle("Efficient frontier 12-2021 to 11-2024") +
  theme_bw()
```

### Plot of cumulative return
#### min_var max_return
```{r}
k <- n
return_min_var[k]
return_max_return[k]

# return for perioden
cumulative_return_min_var <- (cumprod(1+return_min_var/100)-1)*100
cumulative_return_max_return <- (cumprod(1+return_max_return/100)-1)*100

cumulative_return_min_var[k]/n
cumulative_return_max_return[k]/n

sd(return_min_var)
sd(return_max_return)

cumulative_return_df <- tibble(
  "Date" = factors_period$date,
  "Min_var" = cumulative_return_min_var,
  "Max_return" = cumulative_return_max_return
)

cumulative_return_df %>% 
  pivot_longer(cols = -Date, names_to = "Portfolio", values_to = "Cumulated_returns") %>% 
  mutate(Date = ym(Date)) %>% 
  ggplot(aes(Date, Cumulated_returns, color = Portfolio)) +
    geom_line(linewidth = 1) +
    theme_bw() +
    ggtitle("Cumulated returns for the minimum variance and the maximum\n return portfolios") +
    ylab("Cumulated returns") +
    scale_color_manual(
      name = "Portfolio Type",
      labels = c("Maximum Return", "Minimum Variance"),
      values = c("Max_return" = "black", "Min_var" = "red3") 
    )
```

#### Whole frontier
```{r}
cumulative_return_internal <- array(NA, c(n, n_internal))
for(i in 1:n_internal){
  cumulative_return_internal[,i] <- (cumprod(1+return_internal[,i]/100)-1)*100
}

cumulative_return_df <- data.frame(
  cumulative_return_min_var,
  cumulative_return_internal,
  cumulative_return_max_return
)

new_names <- c("Minimum variance", paste("point", 1:5), "max return")

colnames(cumulative_return_df) <- new_names


plot_data <- cumulative_return_df %>%
  mutate(Date = ym(factors_period$date)) %>%
  pivot_longer(
    cols = -Date,
    names_to = "Portfolio",
    values_to = "Cumulative_Return"
  ) %>%
  mutate(Portfolio = factor(Portfolio, levels = new_names))

ggplot(plot_data, aes(x = Date, y = Cumulative_Return, color = Portfolio)) +
  geom_line(linewidth = 0.5) +
  scale_color_viridis_d(option = "cividis") +
  labs(
    title = "Cumulative Returns of Efficient Frontier Portfolios",
    subtitle = "Performance of portfolios from Minimum Variance to Maximum Return",
    x = "Date",
    y = "Cumulative Return",
    color = "Portfolio"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(face = "bold", size = 16),
    plot.subtitle = element_text(size = 12),
    legend.position = "right",
    legend.title = element_text(face = "bold")
  )



c(min(cumulative_return_internal[k,]), max(cumulative_return_internal[k,]))
c(min(cumulative_return_internal[k,]/n), max(cumulative_return_internal[k,]/n))
c(min(apply(return_internal, 2, sd)), max(apply(return_internal, 2, sd)))

which.max(cumulative_return_internal[k,])
which.min(sd(cumulative_return_internal[k,]))
```


# Risk parity
```{r}
n_factors <- ncol(factors[,-1])
n <- nrow(factors)-35-1
w_matrix_rp <- matrix(NA, nrow = n, ncol = n_factors)

for(i in 1:n){
  factors_period <- factors[i:(i+35),-1]
  volatility <- (factors_period %>%
    summarise(across(c(MKT_EU_US, SMB_EU_US, MOM_EU_US, MKT_EU_EU, SMB_EU_EU, MOM_EU_EU), ~sd(.x)))) %>% 
    as.numeric()
  w_matrix_rp[i,] <- 1/volatility/sum(1/volatility)
}

w_rp <- as_tibble(w_matrix_rp)
names(w_rp) <- names(factors[, -1])
w_rp <- w_rp %>% 
  mutate(.before = 1, date = factors$date[37:nrow(factors)])
round(w_rp, 3)

factors_return_calc <- factors[37:nrow(factors),]

return_rp <- rowSums(w_rp[,-1]*factors_return_calc[,-1])
```

## Plot af risk parity
```{r}
k <- 2

cumulative_return_rp <- (cumprod(1+return_rp/100)-1)*100
cumulative_return_mv_chosen <- cumulative_return_internal[,k]

round(cumulative_return_rp[n], 0)-round(cumulative_return_mv_chosen[n], 0)
round(cumulative_return_rp[n]/n, 2) - round(cumulative_return_mv_chosen[n]/n, 2)
round(sd(return_rp), 2)-round(sd(return_internal[,k]), 2)

rp_df <- tibble(
  Date = ym(factors_return_calc$date),
  "Risk parity" = cumulative_return_rp,
  "Chosen mean variance" = cumulative_return_mv_chosen
)


rp_df %>% 
  pivot_longer(cols = -Date, names_to = "Portfolio", values_to = "Cumulative_Return") %>% 
  ggplot(aes(x = Date, y = Cumulative_Return, color = Portfolio)) +
    geom_line(linewidth = 1) +
    labs(
      title = "Cumulative Returns of Risk parity portfolio",
      x = "Date",
      y = "Cumulative Return"
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(face = "bold", size = 16),
      plot.subtitle = element_text(size = 12),
      legend.position = "right",
      legend.title = element_text(face = "bold")
    )
```

```{r}
returns_all <- cbind(
  factors_period$date,
  return_min_var,
  return_internal,
  return_max_return
) %>% 
  as.tibble()

new_names <- c("date", "min_var", paste("Portfolio ", 1:5), "max_return")

colnames(returns_all) <- new_names

cumulative_returns_all <- returns_all %>% 
  
  
```


