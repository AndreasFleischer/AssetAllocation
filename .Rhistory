guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
plot_df <- as.tibble(guarantees)
plot_df <- cbind(tibble(date = All_years$TIME_PERIOD[36:124]), plot_df)
colnames(plot_df) <- c("date", new_names)
plot_df %>%
pivot_longer(cols = -date, names_to = "CPPI_strat", values_to = "Guarantee") %>%
ggplot(aes(x = as.Date(date), y = Guarantee, color = CPPI_strat)) +
geom_line(size = 1.1) +
geom_point(size = 2, alpha = 0.7) +
# geom_line(color = "#0072B2", size = 1.1) +
# geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
# scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
#                    breaks=c("Portfolio.1", "European.Equity"),
#                    labels=c("Portfolio 1", "European Equity")) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
labs(
title = "Development of the Portfolio Guarantee Over Time",
subtitle = "Guarantee level implied by CPPI floor mechanism",
x = "Date",
y = "Guarantee Value"
) +
scale_color_viridis_d(option = "cividis") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
axis.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank()
)
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
ZCB_prices <-  All_years[j:(j+120),] %>%
mutate(
TTM = TTM,
z = BETA0 +
BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
P_T = exp(-z/100 * TTM))
ZCB_prices$P_T[121] <- 1
E_returns <- return_series$return[j:nrow(return_series)]/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
ZCB_prices <-  All_years[j:(j+120),] %>%
mutate(
TTM = TTM,
z = BETA0 +
BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
P_T = exp(-z/100 * TTM))
ZCB_prices$P_T[121] <- 1
E_returns <- return_series$return[j:nrow(return_series)]/100
print(E_returns)
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
ZCB_prices <-  All_years[j:(j+120),] %>%
mutate(
TTM = TTM,
z = BETA0 +
BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
P_T = exp(-z/100 * TTM))
ZCB_prices$P_T[121] <- 1
E_returns <- return_series$return[j:nrow(return_series)]/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years_sorted[j:(j + 120), ]
z <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-z/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
m <- 1
L_target <- 125/100
L_trigger <- 130/100
returns_choice <- readRDS("returns_choice.rds")
mkt_EU_period <- MKT_EU_EU %>% filter(date >= 200709 & date <= 202412)
colnames(mkt_EU_period) <- c("date", "return")
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
z <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-z/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[1]
N <- Floor/ZCB_prices$P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices$P_T[i+1]
W <- A+R
Floor <- N*ZCB_prices$P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices$P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices[1]
N <- Floor/ZCB_prices[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*ZCB_prices[i+1]
W <- A+R
Floor <- N*ZCB_prices[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/ZCB_prices[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
m <- 1
L_target <- 125/100
L_trigger <- 130/100
returns_choice <- readRDS("returns_choice.rds")
mkt_EU_period <- MKT_EU_EU %>% filter(date >= 200709 & date <= 202412)
colnames(mkt_EU_period) <- c("date", "return")
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
Floor <- 80
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/P_T[1]
N <- Floor/P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*P_T[i+1]
W <- A+R
Floor <- N*P_T[i+1]
C <- W-Floor
E <- max(min(m*C,W),0)
A <- E
etaR <- (W-E)/P_T[i+1]
if (W/Floor > L_trigger){
N <- W/L_target
}
}
Guarantees[j-35] <- Floor
}
return(Guarantees)
}
returns_choice <- readRDS("returns_choice.rds")
m <- c(1, 2, 3, 4, 5)
L_target <- c(125, 130)/100
L_trigger <- c(130, 135)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- array(NA, c(nrow(All_years[36:124,]), nrow(search_grid)))
for(i in 1:nrow(search_grid)){
guarantees[,i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
plot_df <- as.tibble(guarantees)
plot_df <- cbind(tibble(date = All_years$TIME_PERIOD[36:124]), plot_df)
colnames(plot_df) <- c("date", new_names)
plot_df %>%
pivot_longer(cols = -date, names_to = "CPPI_strat", values_to = "Guarantee") %>%
ggplot(aes(x = as.Date(date), y = Guarantee, color = CPPI_strat)) +
geom_line(size = 1.1) +
geom_point(size = 2, alpha = 0.7) +
# geom_line(color = "#0072B2", size = 1.1) +
# geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
# scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
#                    breaks=c("Portfolio.1", "European.Equity"),
#                    labels=c("Portfolio 1", "European Equity")) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
labs(
title = "Development of the Portfolio Guarantee Over Time",
subtitle = "Guarantee level implied by CPPI floor mechanism",
x = "Date",
y = "Guarantee Value"
) +
scale_color_viridis_d(option = "cividis") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
axis.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank()
)
