if (W/Floor > L_trigger){
N <- W/(L_target*P_T[i+1])
}
}
Guarantees[j-35] <- Floor
}
return(list("Guarantees" = Guarantees, "Floor" = Floor_month, "C" = C_month))
}
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
guarantees_choice
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
Floor_month <- array(NA, c(120+1, length(36:124)))
C_month <- array(NA, c(120+1, length(36:124)))
E_month <- array(NA, c(120+1, length(36:124)))
W_month <- array(NA, c(120+1, length(36:124)))
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
W_month[1, j+35] <- W
Floor <- 80
Floor_month[1,j-35] <- Floor
C <- W-Floor
C_month[1,j-35] <- C
E <- max(min(m*C,W),0)
E_month[1, j+35] <- E
A <- E
etaR <- (W-E)/P_T[1]
N <- Floor/P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*P_T[i+1]
W <- A+R
W_month[i+1, j+35] <- W
Floor <- N*P_T[i+1]
Floor_month[i+1,j-35] <- Floor
C <- W-Floor
C_month[i+1, j-35] <- C
E <- max(min(m*C,W),0)
E_month[i+1, j+35] <- E
A <- E
etaR <- (W-E)/P_T[i+1]
if (W/Floor > L_trigger){
N <- W/(L_target*P_T[i+1])
}
}
Guarantees[j-35] <- Floor
}
return(list("Guarantees" = Guarantees, "Floor" = Floor_month, "C" = C_month, "W" = W_month, "E" = E_month))
}
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
Floor_month <- array(NA, c(120+1, length(36:124)))
C_month <- array(NA, c(120+1, length(36:124)))
E_month <- array(NA, c(120+1, length(36:124)))
W_month <- array(NA, c(120+1, length(36:124)))
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
W_month[1, j+35] <- W
Floor <- 80
Floor_month[1,j-35] <- Floor
C <- W-Floor
C_month[1,j-35] <- C
E <- max(min(m*C,W),0)
E_month[1, j+35] <- E
A <- E
etaR <- (W-E)/P_T[1]
N <- Floor/P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*P_T[i+1]
W <- A+R
W_month[i+1, j-35] <- W
Floor <- N*P_T[i+1]
Floor_month[i+1,j-35] <- Floor
C <- W-Floor
C_month[i+1, j-35] <- C
E <- max(min(m*C,W),0)
E_month[i+1, j-35] <- E
A <- E
etaR <- (W-E)/P_T[i+1]
if (W/Floor > L_trigger){
N <- W/(L_target*P_T[i+1])
}
}
Guarantees[j-35] <- Floor
}
return(list("Guarantees" = Guarantees, "Floor" = Floor_month, "C" = C_month, "W" = W_month, "E" = E_month))
}
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
TTM <-  seq(10, 0, -1/12)
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
Floor_month <- array(NA, c(120+1, length(36:124)))
C_month <- array(NA, c(120+1, length(36:124)))
E_month <- array(NA, c(120+1, length(36:124)))
W_month <- array(NA, c(120+1, length(36:124)))
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
W_month[1, j-35] <- W
Floor <- 80
Floor_month[1,j-35] <- Floor
C <- W-Floor
C_month[1,j-35] <- C
E <- max(min(m*C,W),0)
E_month[1, j-35] <- E
A <- E
etaR <- (W-E)/P_T[1]
N <- Floor/P_T[1]
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*P_T[i+1]
W <- A+R
W_month[i+1, j-35] <- W
Floor <- N*P_T[i+1]
Floor_month[i+1, j-35] <- Floor
C <- W-Floor
C_month[i+1, j-35] <- C
E <- max(min(m*C,W),0)
E_month[i+1, j-35] <- E
A <- E
etaR <- (W-E)/P_T[i+1]
if (W/Floor > L_trigger){
N <- W/(L_target*P_T[i+1])
}
}
Guarantees[j-35] <- Floor
}
return(list("Guarantees" = Guarantees, "Floor" = Floor_month, "C" = C_month, "W" = W_month, "E" = E_month))
}
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
guarantees_choice
returns_choice <- readRDS("returns_choice.rds")
m <- seq(1, 5, 0.5)
L_target <- seq(120, 140, 5)/100
L_trigger <- seq(125, 145, 5)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger) %>%
filter(L_target < L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
search_grid
new_names
guarantees <- list()
guarantees[1] <- a
guarantees[1] <- 2
guarantees
guarantees[2] <- 2
guarantees
returns_choice <- readRDS("returns_choice.rds")
m <- seq(1, 5, 0.5)
L_target <- seq(120, 140, 5)/100
L_trigger <- seq(125, 145, 5)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger) %>%
filter(L_target < L_trigger)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- list()
for(i in 1:nrow(search_grid)){
guarantees[i] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
guarantees <- list()
guarantees <- list(c(1, 2), array(NA, c(2, 2)))
guarantees <- list()
guarantees
guarantees[1] <- list(c(1, 2), array(NA, c(2, 2)))
guarantees
guarantees <- vector(mode = list, length = 5)
guarantees <- vector(mode = "list", length = 5)
guarantees
guarantees[[1]] <- list(c(1, 2, 3), array(NA, c(2, 2)))
guarantees
guarantees[[2]] <- list(c(1, 2, 3), array(NA, c(2, 2)))
guarantees
guarantees[1] <- list(c(1, 2, 3), array(NA, c(2, 2)))
guarantees <- vector(mode = "list", length = nrow(search_grid))
guarantees
for(i in 1:nrow(search_grid)){
guarantees[[i]] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
guarantees
Guarantees[[1]]
guarantees[[1]]
guarantees[[135]]
names(guarantees)
names(guarantees) <- new_names
names(guarantees) <- new_names
guarantees[[1]]
guarantees[1]
names(guarantees)
library(purrr)
map(guarantees, 1)
map(guarantees, 1)[1]
plot_df <- as.tibble(map(guarantees, 1))
plot_df <- cbind(tibble(date = All_years$TIME_PERIOD[36:124]), plot_df)
colnames(plot_df) <- c("date", new_names)
plot_df %>%
pivot_longer(cols = -date, names_to = "CPPI_strat", values_to = "Guarantee") %>%
ggplot(aes(x = as.Date(date), y = Guarantee, color = CPPI_strat)) +
geom_line(size = 1.1) +
geom_point(size = 2, alpha = 0.7) +
# geom_line(color = "#0072B2", size = 1.1) +
# geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
# scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
#                    breaks=c("Portfolio.1", "European.Equity"),
#                    labels=c("Portfolio 1", "European Equity")) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
labs(
title = "Development of the Portfolio Guarantee Over Time",
subtitle = "Guarantee level implied by CPPI floor mechanism",
x = "Date",
y = "Guarantee Value"
) +
scale_color_viridis_d(option = "cividis") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
axis.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank()
)
plot_df %>%
pivot_longer(cols = -date, names_to = "CPPI_strat", values_to = "Guarantee") %>%
ggplot(aes(x = as.Date(date), y = Guarantee, color = CPPI_strat)) +
geom_line(size = 1.1) +
geom_point(size = 2, alpha = 0.7) +
# geom_line(color = "#0072B2", size = 1.1) +
# geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
# scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
#                    breaks=c("Portfolio.1", "European.Equity"),
#                    labels=c("Portfolio 1", "European Equity")) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
labs(
title = "Development of the Portfolio Guarantee Over Time",
subtitle = "Guarantee level implied by CPPI floor mechanism",
x = "Date",
y = "Guarantee Value"
) +
scale_color_viridis_d(option = "cividis") +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
axis.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank(),
legend.position = "none"
)
solve.QP
optimize_portfolio <- function(excess_returns, cov_period){
n_assets <- length(excess_returns)
Dmat <- cov_period
dvec <- rep(0, n_assets)
Amat <- cbind(rep(1, n_assets), diag(n_assets))
bvec <- c(
1,                   # The value for the first constraint (sum(...) = 1)
rep(0, n_assets)     # The values for the w_i >= 0 constraints
)
meq <- 1
sol<- solve.QP(Dmat = Dmat,
dvec = dvec,
Amat = Amat,
bvec = bvec,
meq = meq)
w <- sol$solution/sum(sol$solution)
return(w)
}
optimize_internal <- function(excess_returns, cov_period, target_return){
n_assets <- length(excess_returns)
Dmat <- cov_period
dvec <- rep(0, n_assets)
Amat <- cbind(excess_returns, rep(1, n_assets), diag(n_assets))
bvec <- c(                   # The value for the first constraint (sum(...) = 1)
target_return,
1,
rep(0, n_assets)     # The values for the w_i >= 0 constraints
)
meq <- 1
sol<- solve.QP(Dmat = Dmat,
dvec = dvec,
Amat = Amat,
bvec = bvec,
meq = meq)
w <- sol$solution/sum(sol$solution)
return(w)
}
optimize_return <- function(excess_returns){
n_assets <- length(excess_returns)
objective.in <- excess_returns
const.mat <- matrix(rep(1, n_assets), nrow = 1)
const.dir <- "=="
const.rhs <- 1
solution <- lp(
direction = "max",
objective.in = objective.in,
const.mat = const.mat,
const.dir = const.dir,
const.rhs = const.rhs
)
return(solution$solution)
}
factors_excess_return <- sweep(factors[,-1], 1, RF.EU$return, "-")
factors_excess_return <- cbind(factors$date, factors_excess_return)
n_assets <- ncol(factors_excess_return[,-1])
n <- nrow(factors_excess_return) - 35 - 1
w_min_var <- matrix(NA, nrow = n, ncol = n_assets)
w_max_return <- matrix(NA, nrow = n, ncol = n_assets)
n_internal <- 5
w_internal <- array(NA, dim = c(n_internal, n, n_assets))
target_returns <- array(NA, c(n, n_internal))
Sigma <- array(NA, c(n, n_assets, n_assets))
mu <- array(NA, c(n, n_assets))
for(i in 1:n){
excess_returns_period <- factors_excess_return[i:(i+35),-1]
mu[i,] <- colMeans(excess_returns_period)
Sigma[i,,] <- cov(excess_returns_period)
if(all(mu <= 0)){
w_min_var[i,] <- 0
w_max_return[i,] <- 0
w_internal[,i , ] <- 0
target_returns[i,] <- 0
} else{
w_min_var[i,] <- optimize_portfolio(mu[i,], Sigma[i,,])
w_max_return[i,] <- optimize_return(mu[i,])
return_min_var <- sum(mu[i,]*w_min_var[i,])
return_max_return <- sum(mu[i,]*w_max_return[i,])
target_returns_tmp <- seq(return_min_var, return_max_return, (return_max_return - return_min_var)/(n_internal+1))
target_returns[i,] <- target_returns_tmp[-c(1, length(target_returns_tmp))]
for(j in 1:length(target_returns[i,])){
w_internal[j,i,] <- optimize_internal(mu[i,], Sigma[i,,], target_returns[i,j])
}
}
}
colnames(w_min_var) <- colnames(factors[,-1])
current_dimnames <- dimnames(w_internal)
current_dimnames[[3]] <- colnames(factors[,-1])
dimnames(w_internal) <- current_dimnames
colnames(w_max_return) <- colnames(factors[,-1])
factors_period <- factors[37:nrow(factors),]
return_min_var <- rowSums(w_min_var*factors_period[,-1])
return_max_return <- rowSums(w_max_return*factors_period[,-1])
return_internal <- array(NA, c(n, n_internal))
for(i in 1:n_internal){
return_internal[,i] <- rowSums(w_internal[i,,]*factors_period[,-1])
}
solve.QP
optimize_portfolio <- function(excess_returns, cov_period){
n_assets <- length(excess_returns)
Dmat <- cov_period
dvec <- rep(0, n_assets)
Amat <- cbind(rep(1, n_assets), diag(n_assets))
bvec <- c(
1,                   # The value for the first constraint (sum(...) = 1)
rep(0, n_assets)     # The values for the w_i >= 0 constraints
)
meq <- 1
sol<- solve.QP(Dmat = Dmat,
dvec = dvec,
Amat = Amat,
bvec = bvec,
meq = meq)
w <- sol$solution/sum(sol$solution)
return(w)
}
optimize_internal <- function(excess_returns, cov_period, target_return){
n_assets <- length(excess_returns)
Dmat <- cov_period
dvec <- rep(0, n_assets)
Amat <- cbind(excess_returns, -rep(1, n_assets), diag(n_assets))
bvec <- c(                   # The value for the first constraint (sum(...) = 1)
target_return,
-1,
rep(0, n_assets)     # The values for the w_i >= 0 constraints
)
meq <- 1
sol<- solve.QP(Dmat = Dmat,
dvec = dvec,
Amat = Amat,
bvec = bvec,
meq = meq)
w <- sol$solution/sum(sol$solution)
return(w)
}
optimize_return <- function(excess_returns){
n_assets <- length(excess_returns)
objective.in <- excess_returns
const.mat <- matrix(rep(1, n_assets), nrow = 1)
const.dir <- "=="
const.rhs <- 1
solution <- lp(
direction = "max",
objective.in = objective.in,
const.mat = const.mat,
const.dir = const.dir,
const.rhs = const.rhs
)
return(solution$solution)
}
factors_excess_return <- sweep(factors[,-1], 1, RF.EU$return, "-")
factors_excess_return <- cbind(factors$date, factors_excess_return)
n_assets <- ncol(factors_excess_return[,-1])
n <- nrow(factors_excess_return) - 35 - 1
w_min_var <- matrix(NA, nrow = n, ncol = n_assets)
w_max_return <- matrix(NA, nrow = n, ncol = n_assets)
n_internal <- 5
w_internal <- array(NA, dim = c(n_internal, n, n_assets))
target_returns <- array(NA, c(n, n_internal))
Sigma <- array(NA, c(n, n_assets, n_assets))
mu <- array(NA, c(n, n_assets))
for(i in 1:n){
excess_returns_period <- factors_excess_return[i:(i+35),-1]
mu[i,] <- colMeans(excess_returns_period)
Sigma[i,,] <- cov(excess_returns_period)
if(all(mu <= 0)){
w_min_var[i,] <- 0
w_max_return[i,] <- 0
w_internal[,i , ] <- 0
target_returns[i,] <- 0
} else{
w_min_var[i,] <- optimize_portfolio(mu[i,], Sigma[i,,])
w_max_return[i,] <- optimize_return(mu[i,])
return_min_var <- sum(mu[i,]*w_min_var[i,])
return_max_return <- sum(mu[i,]*w_max_return[i,])
target_returns_tmp <- seq(return_min_var, return_max_return, (return_max_return - return_min_var)/(n_internal+1))
target_returns[i,] <- target_returns_tmp[-c(1, length(target_returns_tmp))]
for(j in 1:length(target_returns[i,])){
w_internal[j,i,] <- optimize_internal(mu[i,], Sigma[i,,], target_returns[i,j])
}
}
}
colnames(w_min_var) <- colnames(factors[,-1])
current_dimnames <- dimnames(w_internal)
current_dimnames[[3]] <- colnames(factors[,-1])
dimnames(w_internal) <- current_dimnames
colnames(w_max_return) <- colnames(factors[,-1])
factors_period <- factors[37:nrow(factors),]
return_min_var <- rowSums(w_min_var*factors_period[,-1])
return_max_return <- rowSums(w_max_return*factors_period[,-1])
return_internal <- array(NA, c(n, n_internal))
for(i in 1:n_internal){
return_internal[,i] <- rowSums(w_internal[i,,]*factors_period[,-1])
}
dimnames(w_internal) <- current_dimnames
w_internal
rowSums(w_internal)
w_internal
w_internal[1,,]
rowSums(w_internal[1,,])
rowSums(w_internal[2,,])
rowSums(w_internal[3,,])
rowSums(w_internal[4,,])
rowSums(w_internal[5,,])
rowSums(w_internal[6,,])
rowSums(w_internal[5,,])
