guarantees_EU_equity <- CPPI(m, L_target, L_trigger, mkt_EU_period)
m <- 1
L_target <- 125/100
L_trigger <- 130/100
returns_choice <- readRDS("returns_choice.rds")
mkt_EU_period <- MKT_EU_EU %>% filter(date >= 200709 & date <= 202412)
colnames(mkt_EU_period) <- c("date", "return")
guarantees_choice <- CPPI(m, L_target, L_trigger, returns_choice)
guarantees_EU_equity <- CPPI(m, L_target, L_trigger, mkt_EU_period)
guarantee_df <- data.frame(date = All_years$TIME_PERIOD[36:124],
"Portfolio 1" = guarantees_choice$Guarantee_end,
"European Equity" = guarantees_EU_equity$Guarantee_end)
guarantee_df %>%
pivot_longer(cols = -date, names_to = "Portfolio", values_to = "Guarantee") %>%
ggplot(aes(x = as.Date(date), y = Guarantee, color = Portfolio)) +
geom_line(size = 1.1) +
geom_point(size = 2, alpha = 0.7) +
# geom_line(color = "#0072B2", size = 1.1) +
# geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
breaks=c("Portfolio.1", "European.Equity"),
labels=c("Portfolio 1", "European Equity")) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
labs(
title = "Development of the Portfolio Guarantee Over Time",
subtitle = "Guarantee level implied by CPPI floor mechanism",
x = "Date",
y = "Guarantee Value"
) +
theme_minimal(base_size = 13) +
theme(
plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
axis.title = element_text(face = "bold"),
panel.grid.minor = element_blank(),
panel.grid.major.x = element_blank()
)
# # Første spike
# k1 <- which.max(guarantee_df$European.Equity)
# guarantee_df[k1,]
#
# # anden spike
# k2 <- which.max(guarantee_df$European.Equity[(k1+5):nrow(guarantee_df)])
# guarantee_df[k1+4+k2,]
#
# # minimum mellem spikes
# k3 <- which.min(guarantee_df$European.Equity[k1:(k1+k2)])
# guarantee_df[k1:(k1+k2),][k3,]
CPPI <- function(m,L_target,L_trigger,return_series){
Guarantees <- c()
Floor_month <- array(NA, c(120+1, length(36:124)))
C_month <- array(NA, c(120+1, length(36:124)))
E_month <- array(NA, c(120+1, length(36:124)))
W_month <- array(NA, c(120+1, length(36:124)))
Trigger_hit <- array(NA, c(120, length(36:124)))
N_month <- array(NA, c(120+1, length(36:124)))
for (j in 36:124){
# ZCB_prices <-  All_years[j:(j+120),] %>%
#   mutate(
#   TTM = TTM,
#   z = BETA0 +
#     BETA1 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1)) +
#     BETA2 * ((1 - exp(-TTM / TAU1)) / (TTM / TAU1) - exp(-TTM / TAU1)) +
#     BETA3 * ((1 - exp(-TTM / TAU2)) / (TTM / TAU2) - exp(-TTM / TAU2)),
#   P_T = exp(-z/100 * TTM))
# ZCB_prices$P_T[121] <- 1
window_data <- All_years[j:(j + 120), ]
ZCB_prices <- window_data$BETA0 +
window_data$BETA1 * ((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) +
window_data$BETA2 * (((1 - exp(-TTM / window_data$TAU1)) / (TTM / window_data$TAU1)) - exp(-TTM / window_data$TAU1)) +
window_data$BETA3 * (((1 - exp(-TTM / window_data$TAU2)) / (TTM / window_data$TAU2)) - exp(-TTM / window_data$TAU2))
P_T <- exp(-ZCB_prices/100 * TTM)
P_T[121] <- 1 # Manually set the final price to 1.
E_returns <- (return_series %>% filter(ym(date) >= All_years$TIME_PERIOD[j]))$return/100
W <- 100
W_month[1, j-35] <- W
Floor <- W/L_target
Floor_month[1,j-35] <- Floor
C <- W-Floor
C_month[1,j-35] <- C
E <- max(min(m*C,W),0)
E_month[1, j-35] <- E
A <- E
etaR <- (W-E)/P_T[1]
N <- Floor/P_T[1]
N_month[,j-35] <- N
for (i in 1:120){
A <- (1+E_returns[i])*A
R <- etaR*P_T[i+1]
W <- A+R
W_month[i+1, j-35] <- W
Floor <- N*P_T[i+1]
Floor_month[i+1, j-35] <- Floor
C <- W-Floor
C_month[i+1, j-35] <- C
E <- max(min(m*C,W),0)
E_month[i+1, j-35] <- E
A <- E
etaR <- (W-E)/P_T[i+1]
if (W/Floor > L_trigger){
N <- W/(L_target*P_T[i+1])
Trigger_hit[i, j-35] <- 1
}else{
Trigger_hit[i, j-35] <- 0
}
N_month[i,j-35] <- N
}
Guarantees[j-35] <- W
}
return(list("Guarantee" = Guarantees, "Floor" = Floor_month, "C" = C_month, "Wealth_month" = W_month, "E" = E_month, "Trigger_hit" = Trigger_hit, "Guarantee_month" = N_month))
}
returns_choice <- readRDS("returns_choice.rds")
# m <- seq(1, 20, 0.5)
m <- seq(1, 20, 0.5)
L_target <- seq(105, 200, 5)/100
L_trigger <- seq(110, 230, 5)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger) %>%
filter(L_target < L_trigger & L_trigger - L_target <= 0.3)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees <- vector(mode = "list", length = nrow(search_grid))
for(i in 1:nrow(search_grid)){
guarantees[[i]] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
names(guarantees) <- new_names
guarantees <- readRDS("C:/Users/Nikolaj/OneDrive - University of Copenhagen/Aktuar/5. år/Asset allocation/Exam project/CPPI_strats.rds")
plot_df <- as_tibble(map(guarantees, 1))
plot_df <- cbind(tibble(date = All_years$TIME_PERIOD[36:124]), plot_df)
colnames(plot_df) <- c("date", new_names)
# plot_df %>%
#   pivot_longer(cols = -date, names_to = "CPPI_strat", values_to = "Guarantee") %>%
#   ggplot(aes(x = as.Date(date), y = Guarantee, color = CPPI_strat)) +
#     geom_line(size = 1.1) +
#     geom_point(size = 2, alpha = 0.7) +
#     # geom_line(color = "#0072B2", size = 1.1) +
#     # geom_point(color = "#0072B2", size = 2, alpha = 0.7) +
#     # scale_color_manual(values = c("Portfolio.1" = "#0072B2", "European.Equity" = "#D55E00"),
#     #                    breaks=c("Portfolio.1", "European.Equity"),
#     #                    labels=c("Portfolio 1", "European Equity")) +
#     scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
#     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
#     labs(
#       title = "Development of the Portfolio Guarantee Over Time",
#       subtitle = "Guarantee level implied by CPPI floor mechanism",
#       x = "Date",
#       y = "Guarantee Value"
#     ) +
#   scale_color_viridis_d(option = "cividis") +
#     theme_minimal(base_size = 13) +
#     theme(
#       plot.title = element_text(face = "bold", size = 15, hjust = 0.5),
#       plot.subtitle = element_text(size = 11, hjust = 0.5, color = "gray40"),
#       axis.title = element_text(face = "bold"),
#       panel.grid.minor = element_blank(),
#       panel.grid.major.x = element_blank(),
#       legend.position = "none"
#     )
K <- map(guarantees, "Guarantee_end")
B <- map(guarantees, "C")
K <- map(guarantees, "Guarantee_end")
# Rækker er start på periode
# Søjler er parameter kombination
# short_fall er andelen af alle perioder, hvor man falder under floor
short_fall <- array(NA, dim = c(ncol(B[[1]]), length(B)))
guarantees_min <- rep(NA, length(K))
for(i in 1:length(B)){
short_fall[,i] <- (colSums(B[[i]] <= 0) > 0)
}
check_m <- paste(m, "x", sep = "")
k <- length(which(startsWith(new_names, check_m[1])))
indices_m <- array(NA, c(k, length(m)))
for(i in 1:length(m)){
indices_m[,i] <- which(startsWith(new_names, check_m[i]))
}
A <- colMeans(short_fall)
dim(indices_m)
short_fall_df <- matrix(A[indices_m], nrow = nrow(indices_m), ncol = ncol(indices_m), byrow = FALSE)
short_fall_df <- as.tibble(short_fall_df)
guarantees_m_df <- matrix(guarantees[indices_m], nrow = nrow(indices_m), ncol = ncol(indices_m), byrow = FALSE)
guarantees_m_df <- as.tibble(guarantees_m_df)
colnames(short_fall_df) <- m
colnames(guarantees_m_df) <- m
guarantees_m_plot_df <- guarantees_m_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Guarantee") %>%
group_by(m) %>%
summarise("Mean_guarantee" = mean(Guarantee))
short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
left_join(guarantees_m_plot_df, by = "m") %>%
ggplot(aes(as.numeric(m), short_fall_prop_m)) +
geom_point()
library(purrr)
library(stringr)
library(dplyr)
library(purrr)
library(stringr)
library(dplyr)
# 1. Create the detailed 'min_df' dataframe
min_df <- K %>%
imap_dfr(~ {
# .y is the name (e.g., "7x1.25x1.3"), .x is the vector
parts <- str_split(.y, "x", simplify = TRUE)
tibble(
m = parts[1],
Target = parts[2],
Trigger = parts[3],
min_value = min(.x)
)
})
# Print the resulting min_df
print(min_df)
# 2. Group and summarize (this code is the same as before)
mean_of_mins_df <- min_df %>%
group_by(m) %>%
summarize(
mean_of_mins = mean(min_value)
) %>%
mutate(m = as.numeric(m)) %>%
arrange(m)
# Print the final aggregated dataframe
print(mean_of_mins_df)
mean(sapply(K, min)[1:106])
# Shortfall and minimum guarantee
df_cleaned <- short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
cbind(mean_of_mins_df$mean_of_mins) %>%
rename(mean_of_mins = `mean_of_mins_df$mean_of_mins`) %>%
mutate(m = as.numeric(m))
scale_factor <- max(df_cleaned$short_fall_prop_m) / max(df_cleaned$mean_of_mins)
ggplot(df_cleaned, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_mins * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_mins * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "Minimum guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "Mean of Mins" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of Mins by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
# 1. Create the detailed 10% 'quantile_df' dataframe
quantile_df <- K %>%
imap_dfr(~ {
# .y is the name (e.g., "7x1.25x1.3"), .x is the vector
parts <- str_split(.y, "x", simplify = TRUE)
tibble(
m = parts[1],
Target = parts[2],
Trigger = parts[3],
quantile_10 = quantile(.x, p = 0.1)
)
})
quantile_df
# Shortfall and 10% quantile guarantee
df_cleaned_quantile <- short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
cbind(mean_of_quantile_df$mean_of_quantile) %>%
rename(mean_of_quantile = `mean_of_quantile_df$mean_of_quantile`) %>%
mutate(m = as.numeric(m))
# 2. Group and summarize (this code is the same as before)
mean_of_quantile_df <- quantile_df %>%
group_by(m) %>%
summarize(
mean_of_quantile = mean(quantile_10)
) %>%
mutate(m = as.numeric(m)) %>%
arrange(m)
# Shortfall and 10% quantile guarantee
df_cleaned_quantile <- short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
cbind(mean_of_quantile_df$mean_of_quantile) %>%
rename(mean_of_quantile = `mean_of_quantile_df$mean_of_quantile`) %>%
mutate(m = as.numeric(m))
scale_factor <- max(df_cleaned$short_fall_prop_m) / max(df_cleaned$mean_of_mins)
ggplot(df_cleaned, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_mins * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_mins * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "Minimum guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "Mean of Mins" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of Mins by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
# Shortfall and 10% quantile guarantee
df_cleaned_quantile <- short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
cbind(mean_of_quantile_df$mean_of_quantile) %>%
rename(mean_of_quantile = `mean_of_quantile_df$mean_of_quantile`) %>%
mutate(m = as.numeric(m))
df_cleaned_quantile
# Shortfall and 10% quantile guarantee
df_cleaned_quantile <- short_fall_df %>%
pivot_longer(cols = everything(), names_to = "m", values_to = "Short_fall_prop") %>%
group_by(m) %>%
summarise(short_fall_prop_m = mean(Short_fall_prop)) %>%
arrange(as.numeric(m)) %>%
cbind(mean_of_quantile_df$mean_of_quantile) %>%
rename(mean_of_quantile = `mean_of_quantile_df$mean_of_quantile`) %>%
mutate(m = as.numeric(m))
scale_factor <- max(df_cleaned_quantile$short_fall_prop_m) / max(df_cleaned$mean_of_quantile)
ggplot(df_cleaned, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_quantile * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_quantile * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "10% quantile guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "mean of quantile" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of Mins by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
ggplot(df_cleaned_quantile, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_quantile * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_quantile * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "10% quantile guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "mean of quantile" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of Mins by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
df_cleaned_quantile
df_cleaned$mean_of_quantile
df_cleaned_quantile
scale_factor <- max(df_cleaned_quantile$short_fall_prop_m) / max(df_cleaned_quantile$mean_of_quantile)
scale_factor
scale_factor <- max(df_cleaned_quantile$short_fall_prop_m) / max(df_cleaned_quantile$mean_of_quantile)
ggplot(df_cleaned_quantile, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_quantile * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_quantile * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "10% quantile guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "mean of quantile" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of Mins by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
ggplot(df_cleaned_quantile, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_quantile * scale_factor, color = "Mean of Mins"), size = 1.2) +
geom_point(aes(y = mean_of_quantile * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "10% quantile guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "mean of quantile" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of 10 euantile by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
ggplot(df_cleaned_quantile, aes(x = m)) +
geom_line(aes(y = short_fall_prop_m, color = "Shortfall Prop"), size = 1.2) +
geom_point(aes(y = short_fall_prop_m), color = "#0072B2", size = 2.5) +
geom_line(aes(y = mean_of_quantile * scale_factor, color = "mean of quantile"), size = 1.2) +
geom_point(aes(y = mean_of_quantile * scale_factor), color = "#D55E00", size = 2.5) +
scale_y_continuous(
name = "Shortfall Probability",
labels = scales::percent_format(accuracy = 0.01),
sec.axis = sec_axis(
trans = ~ . / scale_factor,
name = "10% quantile guarantee"
)
) +
scale_x_continuous(breaks = seq(1, 20, by = 2)) +
scale_color_manual(
name = "Metric",
values = c("Shortfall Prop" = "#0072B2", "mean of quantile" = "#D55E00")
) +
labs(
title = "Shortfall Probability vs. Mean of 10 euantile by Multiplier",
x = "Multiplier (m)"
) +
theme_minimal() +
theme(legend.position = "top")
returns_choice <- readRDS("returns_choice.rds")
# m <- seq(1, 20, 0.5)
m <- 2.5
L_target <- seq(105, 200, 1)/100
L_trigger <- seq(110, 230, 1)/100
search_grid = expand.grid(m = m, "L_target" = L_target, "L_trigger" = L_trigger) %>%
filter(L_target < L_trigger & L_trigger - L_target <= 0.3)
search_grid <- sort_by(search_grid, ~list(m, L_target, L_trigger))
new_names <- apply(search_grid, 1, paste, collapse = "x")
# set1 <- m
# set2 <- L_target*100
# set3 <- L_trigger*100
# all_combinations_df <- expand.grid(set1, set2, set3)
# new_names <- apply(all_combinations_df, 1, paste, collapse = "x")
guarantees_trigger_target <- vector(mode = "list", length = nrow(search_grid))
for(i in 1:nrow(search_grid)){
guarantees_trigger_target[[i]] <- CPPI(search_grid[i,1], search_grid[i,2], search_grid[i,3], returns_choice)
}
names(guarantees_trigger_target) <- new_names
wealth <- map(guarantees_trigger_target, "Wealth_month")
last_row_list <- lapply(wealth, function(x) x[nrow(x), ])
wealth_df <- tibble(date = All_years$TIME_PERIOD[36:124]) %>%
cbind(last_row_list)
df <- tibble(strings = new_names)
# 3. Use 'extract' to split the string into new columns
# "(\\d+)" is a regular expression for "one or more digits"
# 'convert = TRUE' automatically makes M, K, and L numeric
df_with_diff <- df %>%
extract(strings,
into = c("m", "Target", "Trigger"),
# This regex now matches decimals
"([\\d\\.]+)x([\\d\\.]+)x([\\d\\.]+)",
convert = TRUE) %>%
mutate(Difference = Trigger - Target)
colnames(wealth_df) <- c("date", round(df_with_diff$Difference, 3))
plot(colMeans(wealth_df[,-1]))
saveRDS(guarantees_trigger_target, "guarantees_m_2.5")
